// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package cmd

import (
	"github.com/darkcrux/webhook-manager/internal/component/customer"
	"github.com/darkcrux/webhook-manager/internal/component/notification"
	"github.com/darkcrux/webhook-manager/internal/component/transport"
	"github.com/darkcrux/webhook-manager/internal/component/txtypes"
	"github.com/darkcrux/webhook-manager/internal/component/webhook"
	"github.com/darkcrux/webhook-manager/internal/entrypoint/api/rest"
	customer2 "github.com/darkcrux/webhook-manager/internal/entrypoint/api/rest/customer"
	notification2 "github.com/darkcrux/webhook-manager/internal/entrypoint/api/rest/notification"
	txtypes2 "github.com/darkcrux/webhook-manager/internal/entrypoint/api/rest/txtypes"
	webhook2 "github.com/darkcrux/webhook-manager/internal/entrypoint/api/rest/webhook"
	kafka2 "github.com/darkcrux/webhook-manager/internal/infrastructure/kafka"
	"github.com/darkcrux/webhook-manager/internal/infrastructure/postgres"
	"github.com/darkcrux/webhook-manager/internal/infrastructure/postgres/repository"
	"github.com/gorilla/mux"
	"github.com/jinzhu/gorm"
	"github.com/segmentio/kafka-go"
	"github.com/sirupsen/logrus"
	"os"
)

import (
	_ "github.com/lib/pq"
)

// Injectors from wire.go:

func createRestAPI() *rest.API {
	cmdAppConfig := ProvideConfig()
	config := ProvideRestAPIConfig(cmdAppConfig)
	router := mux.NewRouter()
	datasource := ProvideDatasource(cmdAppConfig)
	db := ProvideGormDB(datasource)
	txtypesRepository := repository.NewGormTxTypeRepository(db)
	service := txtypes.NewDefaultService(txtypesRepository)
	controller := txtypes2.NewController(service)
	customerRepository := repository.NewGormCustomerRepository(db)
	customerService := customer.NewDefaultService(customerRepository)
	customerController := customer2.NewController(customerService)
	webhookRepository := repository.NewGormWebhookRepository(db)
	webhookService := webhook.NewDefaultService(webhookRepository)
	webhookController := webhook2.NewController(webhookService)
	notificationRepository := repository.NewGormNotificationRepository(db)
	messageBus := ProvideMessageBus(cmdAppConfig)
	transportService := transport.NewDefaultService(messageBus)
	notificationService := notification.NewDefaultService(notificationRepository, webhookService, service, customerService, transportService)
	notificationController := notification2.NewController(notificationService)
	api := rest.NewRestAPI(config, router, controller, customerController, webhookController, notificationController)
	return api
}

func createMigration() *postgres.Migration {
	cmdAppConfig := ProvideConfig()
	datasource := ProvideDatasource(cmdAppConfig)
	migration := postgres.NewMigration(datasource)
	return migration
}

// wire.go:

func ProvideConfig() appConfig {
	config, err := loadConfig()
	if err != nil {
		logrus.WithError(err).Error("unable to unmarshal configuration")
		os.Exit(1)
	}
	return config
}

func ProvideDatasource(config appConfig) *postgres.Datasource {
	return &postgres.Datasource{
		Type:       config.Datasource.Type,
		Host:       config.Datasource.Host,
		Port:       config.Datasource.Port,
		Database:   config.Datasource.Database,
		Username:   config.Datasource.Username,
		Password:   config.Datasource.Password,
		SSLMode:    config.Datasource.SSLMode,
		Migrations: config.Datasource.Migrations,
	}
}

func ProvideRestAPIConfig(config appConfig) *rest.Config {
	restConfig2 := &rest.Config{
		Host:    config.API.REST.Host,
		Port:    config.API.REST.Port,
		Spec:    config.API.REST.Spec,
		Version: "dev",
		Cors: rest.CORSConfig{
			AllowedOrigins: config.API.REST.CORS.AllowedOrigins,
			AllowedHeaders: config.API.REST.CORS.AllowedHeaders,
			AllowedMethods: config.API.REST.CORS.AllowedMethods,
		},
	}
	logrus.Info("========================================")
	logrus.Info("API Configuration")
	logrus.Info("========================================")
	logrus.Info("Host:    ", restConfig2.Host)
	logrus.Info("Port:    ", restConfig2.Port)
	logrus.Info("Spec:    ", restConfig2.Spec)
	logrus.Info("Version: ", restConfig2.Port)
	return restConfig2
}

func ProvideGormDB(datasource *postgres.Datasource) *gorm.DB {
	db, err := gorm.Open("postgres", datasource.AsPQString())
	if err != nil {
		logrus.WithError(err).Error("unable to get gorm db connection")
		os.Exit(1)
	}
	return db
}

func ProvideMessageBus(config appConfig) transport.MessageBus {
	notifWriter := kafka.NewWriter(kafka.WriterConfig{
		Brokers:  config.Kafka.Brokers,
		Topic:    "notif.send",
		Balancer: &kafka.LeastBytes{},
	})
	notifStatusWriter := kafka.NewWriter(kafka.WriterConfig{
		Brokers:  config.Kafka.Brokers,
		Topic:    "notif.update",
		Balancer: &kafka.LeastBytes{},
	})
	notifReader := kafka.NewReader(kafka.ReaderConfig{
		Brokers:  config.Kafka.Brokers,
		GroupID:  "notif.senders",
		Topic:    "notif.send",
		MinBytes: config.Kafka.MinBytes,
		MaxBytes: config.Kafka.MaxBytes,
	})
	notifStatusReader := kafka.NewReader(kafka.ReaderConfig{
		Brokers:  config.Kafka.Brokers,
		GroupID:  "notif.updaters",
		Topic:    "notif.update",
		MinBytes: config.Kafka.MinBytes,
		MaxBytes: config.Kafka.MaxBytes,
	})
	return kafka2.NewKafkaNotifMessageBus(notifWriter, notifStatusWriter, notifReader, notifStatusReader)
}
